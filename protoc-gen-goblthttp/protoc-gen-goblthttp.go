package main

import (
	"fmt"
	"strings"

	// "google.golang.org/genproto/googleapis/api/annotations"
	// "google.golang.org/genproto/googleapis/api/serviceconfig"
	"github.com/BetaLixT/golang-tooling/protoc-gen-goblthttp/custom/annotations"
	"github.com/BetaLixT/golang-tooling/protoc-gen-goblthttp/pkg"
	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/types/descriptorpb"
	// "google.golang.org/protobuf/proto"
	// "google.golang.org/protobuf/runtime/protoimpl"
	// "google.golang.org/protobuf/types/descriptorpb"
	// "google.golang.org/protobuf/proto"
	// "google.golang.org/protobuf/types/descriptorpb"
)

func main() {
	protogen.Options{}.Run(func(p *protogen.Plugin) error {
		for _, f := range p.Files {
			if f.Generate {
				if err := GenerateFile(p, f); err != nil {
					return err
				}
			}
		}

		return nil
	})
}

// GenerateFile generate
func GenerateFile(
	plugin *protogen.Plugin,
	file *protogen.File,
) error {
	isGenerated := false
	for _, srv := range file.Services {
		for _, method := range srv.Methods {
			if method.Desc.IsStreamingClient() || method.Desc.IsStreamingServer() {
				continue
			}
			isGenerated = true
		}
	}

	if !isGenerated {
		return nil
	}
	plugin.SupportedFeatures = 1
	protojsonPackage := protogen.GoImportPath("google.golang.org/protobuf/encoding/protojson")
	gofilename := file.GeneratedFilenamePrefix + ".http.go"
	gohttp := plugin.NewGeneratedFile(gofilename, file.GoImportPath)

	gohttp.P("// Code generated by protoc-gen-gohttp. DO NOT EDIT.")
	gohttp.P("// source: ", file.Desc.Path())
	gohttp.P()
	gohttp.P("package ", file.GoPackageName)
	gohttp.P("const InternalContextKey = \"inCxt\"")
	gohttp.P(
		"var protomarsh = ",
		protojsonPackage.Ident("MarshalOptions"),
		"{EmitUnpopulated: true}",
	)

	yamlfilename := file.GeneratedFilenamePrefix + ".http.yaml"
	openapi := plugin.NewGeneratedFile(yamlfilename, file.GoImportPath)

	openapi.P("# Code generated by protoc-gen-gohttp. DO NOT EDIT.")
	openapi.P("# source: ", file.Desc.Path())

	jsonfilename := file.GeneratedFilenamePrefix + ".http.json"
	openapijson := plugin.NewGeneratedFile(jsonfilename, file.GoImportPath)
	permsjson := plugin.NewGeneratedFile(
		file.GeneratedFilenamePrefix+".perms.json",
		file.GoImportPath,
	)

	cnqs := map[string]struct{}{}
	srvs := []pkg.Server{}
	allPaths := map[string]struct{}{}
	for _, srv := range file.Services {
		// if err := genService(g, srv); err != nil {
		// 	return err
		// }

		pths := []pkg.APIPath{}
		for _, rpc := range srv.Methods {
			if _, ok := cnqs[rpc.Input.GoIdent.GoName]; !ok {
				cnqs[rpc.Input.GoIdent.GoName] = struct{}{}
			} else {
				return fmt.Errorf("command/query used multiple times %s", rpc.Input.GoIdent.GoName)
			}

			var path string
			if strings.Contains(rpc.Input.GoIdent.GoName, "Command") {
				cmd := pkg.ToPrivateName(strings.TrimSuffix(rpc.Input.GoIdent.GoName, "Command"))
				path = "/commands/" + cmd
			} else if strings.Contains(rpc.Input.GoIdent.GoName, "Query") {
				cmd := pkg.ToPrivateName(strings.TrimSuffix(rpc.Input.GoIdent.GoName, "Query"))
				path = "/queries/" + cmd
			} else {
				return fmt.Errorf("non command/query model used as input %s", rpc.Input.GoIdent.GoName)
			}

			options, ok := rpc.Desc.Options().(*descriptorpb.MethodOptions)
			if !ok {
				return fmt.Errorf("documentation missing from rpc")
			}

			doc, ok := proto.GetExtension(options, annotations.E_Documentation).(*annotations.Documentation)
			if !ok {
				return fmt.Errorf("documentation missing from rpc")
			}
			method := "POST"

			if doc.Rules != nil {
				switch doc.Rules.GetPattern().(type) {
				case *annotations.HttpRule_Get:
					method = "GET"
					path = doc.Rules.GetGet()
				case *annotations.HttpRule_Put:
					method = "PUT"
					path = doc.Rules.GetPut()
				case *annotations.HttpRule_Post:
					method = "POST"
					path = doc.Rules.GetPost()
				case *annotations.HttpRule_Delete:
					method = "DELETE"
					path = doc.Rules.GetDelete()
				case *annotations.HttpRule_Patch:
					method = "PATCH"
					path = doc.Rules.GetPatch()
				default:
					continue
				}
			}

			fmtPath, pattern, pathKeys := parsePath(path)
			reg := method + ":" + pattern
			if _, ok = allPaths[reg]; ok {
				return fmt.Errorf("duplicate path found")
			}
			allPaths[reg] = struct{}{}

			pth := pkg.APIPath{
				rpc,
				doc.Tags,
				doc.Roles,
				doc.Features,
				doc.Summary,
				doc.Description,
				fmtPath,
				path,
				method,
				[]pkg.Parameter{},
			}
			pth.BuildParameters(pathKeys)

			pths = append(pths, pth)

		}
		srvs = append(srvs, pkg.Server{
			Service: srv,
			Paths:   pths,
		})
	}

	err := pkg.GenerateHTTPServers(srvs, gohttp, file)
	if err != nil {
		return err
	}

	err = pkg.GeneratePermisionMaps(srvs, permsjson)
	if err != nil {
		return err
	}

	srvs2 := []pkg.Server{}
	for idx := range srvs {
		pths := []pkg.APIPath{}
		for _, pth := range srvs[idx].Paths {
			for _, tag := range pth.Tags {
				if tag == "public" {
					pths = append(pths, pth)
					break
				}
			}
		}
		if len(pths) != 0 {
			srvs2 = append(srvs2, pkg.Server{srvs[idx].Service, pths})
		}
	}

	return pkg.GenerateOpenAPI(srvs, openapi, openapijson, file)
}

func parsePath(
	path string,
) (formattedPath string, matchedPattern string, pathKeys map[string]string) {
	segments := strings.Split(path, "/")
	patternSegments := make([]string, len(segments))
	pathKeys = map[string]string{}

	for idx := range segments {
		if len(segments[idx]) > 0 &&
			(segments[idx][0] == '{' && segments[idx][len(segments[idx])-1] == '}') {

			variable := make([]rune, len(segments[idx])-2)
			for ridx := 1; ridx < len(segments[idx])-1; ridx++ {

				if segments[idx][ridx] == '=' {
					panic(
						"path templating not currently supported, ex: {var} is supported not {var=*}",
					)
				}
				variable[ridx-1] = rune(segments[idx][ridx])
			}
			varstr := string(variable)
			pathKeys[varstr] = string(varstr)
			segments[idx] = ":" + varstr
			patternSegments[idx] = ":var"
		} else {
			patternSegments[idx] = segments[idx]
		}
	}
	return strings.Join(segments, "/"), strings.Join(patternSegments, "/"), pathKeys
}
